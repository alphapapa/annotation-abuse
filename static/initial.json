{"project":{"paths":{"base":"/Users/zmitchell/Projects/annotation-abuse","code_paths":["/Users/zmitchell/Projects/annotation-abuse/annotation_abuse","/Users/zmitchell/Projects/annotation-abuse/tests"],"exclude_code_paths":["/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/__pycache__","/Users/zmitchell/Projects/annotation-abuse/tests/__pycache__"],"artifact_paths":["/Users/zmitchell/Projects/annotation-abuse/design"],"exclude_artifact_paths":[]},"code_impls":{"SPC-asts":{"primary":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":20},"secondary":{".ast2func":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":145},".bind":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":300},".collect":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":61},".decorator":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":21},".extract":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":100},".getter":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":157},".initast":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":268},".item":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":44},".parse":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":82},".property":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":309},".setter":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":211},".statements":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":288},".tst-comparison":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":85},".tst-equal":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":173},".tst-init_stmts":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":210},".tst-in_range":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":187},".tst-mixed_strings":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":62},".tst-not_comparison":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":74},".tst-no_annotations":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":41},".tst-no_strings":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":51},".tst-order":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":154},".tst-outside_range":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":198},".tst-rejects_funcs":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":21},".tst-rejects_inf_nan":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":137},".tst-rejects_methods":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":31},".tst-valid_floats":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":117},".tst-valid_ints":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":97}}},"SPC-notify":{"primary":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":0},"secondary":{".classvars":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":70},".decorator":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":55},".tst-arb_ann":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":30},".tst-marked_classvars":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":16}}},"SPC-notify-inst":{"primary":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":142},"secondary":{".cache":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":116},".inherits":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":85},".initast":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":131},".modast":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":95},".tst-detects_tests":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":59},".tst-find_ann":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":78},".tst-impl_init":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":40},".tst-inherits_init":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":50}}},"SPC-notify-intercept":{"primary":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":181},"secondary":{".input":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":260},".msg":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":209},".tst-intercepts_class":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":113},".tst-intercepts_inst":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":92},".tst-prompt_invalid":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":187},".tst-prompt_no":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":180},".tst-prompt_yes":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":174},".tst-unmarked_class":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":154},".tst-unmarked_inst":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":133}}}},"artifacts":{"REQ-asts":{"id":"CNlGR4RoPUovPQiv9QBtWg","name":"REQ-asts","file":"/Users/zmitchell/Projects/annotation-abuse/design/REQ-asts.md","partof":["REQ-purpose"],"parts":["SPC-asts"],"completed":{"spc":1.0,"tst":1.0},"text":"\nThis project started as an exploration into whether it is possible to create Rust-style macros in Python. Procedural macros in Rust are functions that, when applied to a struct, function, etc, are passed the abstract syntax tree (AST) of the respective item. The function operates on the AST, performing some computations i.e. code generation, and returns the AST that should replace the original AST.\n\nThis example will provide a macro (class decorator) that generates instance properties from specially annotated class variables.\n\n- The macro shall be called `inrange`.\n- The macro shall accept class variable annotations of the form `\"lower < class_var < upper\"`, where `upper` and `lower` must be literal numeric values.\n- The macro shall only accept closed ranges i.e. ranges with both `upper` and `lower` specified.\n- The macro shall only accept the `<` operator, for simplicity.\n- An exception shall be raised if the annotation does not conform to the specified format.\n- The macro shall generate a setter that only accepts values in the range specified by the annotation.\n- The macro shall operate on the AST of the class being decorated.\n- The macro shall generate functions/methods via constructing ASTs.\n","impl_":{"type":"NotImpl"},"subnames":[]},"REQ-notify":{"id":"b5eqAaDewMq8Xg1YdNt91w","name":"REQ-notify","file":"/Users/zmitchell/Projects/annotation-abuse/design/REQ-notify.md","partof":["REQ-purpose"],"parts":["SPC-notify"],"completed":{"spc":1.0,"tst":1.0},"text":"\nThis project shall implement a decorator that prints a notification to the terminal when a new value is assigned to a designated class or instance attribute.\n\n- The decorator shall allow only a single field to be designed per class.\n- The designated field shall be marked by placing the string \"this one\" in the field's annotation.\n- When the field is assigned to, a message shall be printed to the terminal indicating the current value and the value to be assigned.\n","impl_":{"type":"NotImpl"},"subnames":[]},"REQ-purpose":{"id":"BsjVhe7NoIYlCsD9yoPWCg","name":"REQ-purpose","file":"/Users/zmitchell/Projects/annotation-abuse/design/REQ-purpose.md","partof":[],"parts":["REQ-asts","REQ-notify"],"completed":{"spc":1.0,"tst":1.0},"text":"Python introduced type annotations in Python 3.5. Traditionally, a variable annotation contains the type of the variable, but it may contain any valid Python expression. The purpose of `annotation-abuse` is to illustrate some applications of storing arbitrary data in annotations.\n\nNone of the examples shown here are intended to be used in production code. Each example is best viewed as a proof of concept. The code should be documented in such a way that the unfamiliar parts of Python are made easily accessible to a beginner.\n","impl_":{"type":"NotImpl"},"subnames":[]},"SPC-asts":{"id":"49jeCvK7yHEcBHGbG0NDyg","name":"SPC-asts","file":"/Users/zmitchell/Projects/annotation-abuse/design/SPC-asts.md","partof":["REQ-asts"],"parts":[],"completed":{"spc":1.0,"tst":1.0},"text":"The `inrange` macro shall read the annotations of the class variables in the class definition, and generate properties with the same names as the annotated class variables. Annotations for class variables are stored in the `MyClass.__annotations__` dictionary. If this class attribute does not exist, it means that there are no annotated class variables. An exception shall be raised if there are no annotations.\n\nFor the class definition\n```python\nclass MyClass:\n    foo: \"0 < foo < 10\"\n```\nthe macro should generate a class equivalent to\n```python\nclass MyClass:\n    foo: \"0 < foo < 10\"\n\n    def __init__(self):\n        self._foo = None\n\n    @property\n    def foo(self):\n        return self._foo\n\n    @foo.setter\n    def foo(self, value):\n        if (value > 0) and (value < 10):\n            self._foo = value\n```\n\nThe process for constructing the class is as follows:\n- Collect the class variables with annotations.\n- Parse each annotation into an AST.\n- Extract the endpoints of each range.\n- Construct each getter AST.\n- Construct each setter AST.\n- Convert the getter/setter ASTs to functions.\n- Construct a property from the getter and setter functions.\n- Add all new properties to the class.\n- Construct an `__init__` method AST.\n- Modify the `__init__` AST to create the instance variables that back the properties.\n- Compile the `__init__` AST to a function.\n- Bind the `__init__` function to the class.\n\n## [[.item]]\nThe information about each class variable that has been selected for processing shall be bundled into an instance of the `MacroItem` class. The `MacroItem` class shall store the following pieces of data:\n- The name of the class variable.\n- The original annotation string.\n- The numeric value of the range's lower bound.\n- The numeric value of the range's upper bound.\n- The getter function.\n- The setter function.\n- The AST of the initialization statement.\n\n## [[.decorator]]\nThe decorator shall only be applied to a class definition. A `MacroError` shall be raised if the decorator is applied to an object for which `type(my_object)` is not `type`.\n\nThe decorator should follow this sequence of events:\n- Check the type of the argument.\n- Check that annotations exist.\n- Return the new class definition.\n\n### Unit Tests\nInvalid inputs:\n- [[.tst-rejects_funcs]]: Test that the decorator raises a `MacroError` when applied to a function definition.\n- [[.tst-rejects_methods]]: Test that the decorator raises a `MacroError` when applied to a method definition.\n- [[.tst-no_annotations]]: Test that applying the decorator to a class with no annotations raises a `MacroError`.\n\n## [[.collect]]\nFor each `field: annotation` in `cls.__annotations__` the processor shall:\n- Skip `field` if `annotation` is not a string.\n- Construct a `MacroItem` from `field` and `annotation`.\n- Add the item to `self._items`.\n\n### Unit Tests\nInvalid inputs:\n- [[.tst-no_strings]]: Test that a `MacroError` is raised if none of the annotations are strings.\nValid inputs:\n- [[.tst-mixed_strings]]: Test that class variables with string annotations are collected.\n\n## [[.parse]]: Parse annotations into ASTs\nThe annotation should be passed straight to `ast.parse`, which will return an `ast.Module`. The `ast.Compare` node shall be extracted from the module AST.\n\nIf the string is properly formatted, the module's `body` field will contain a single item: an `ast.Expr` node. The expression's `value` field should be an `ast.Compare` node.\n\n### Unit Tests\nInvalid inputs:\n- [[.tst-not_comparison]]: Test that a `MacroError` is raised when nodes not of type `ast.Compare` are found in the parsed annotation.\nValid inputs:\n- [[.tst-comparison]]: Test that the processor correctly extracts the `ast.Compare` node when it is present.\n\n## [[.extract]]: Extract range endpoints\nAn expression of the form `x < y < 5` will produce the following node:\n```\nCompare(left=Name(id='x', ctx=ast.Load()),\n        ops=[\n            ast.Lt(),\n            ast.Lt(),\n        ],\n        comparators=[\n            ast.Name(id='y', ctx=ast.Load()),\n            ast.Num(n=5),\n        ],\n)\n```\nNote that although you would typically read this expression as \"y is greater than x and less than 5\", the node stores this as \"x is less than y, which is less than 5\".\n\nA value that appears with a negative sign (`-`) in front of it will be wrapped in an `ast.UnaryOp` node, like so:\n```\nast.UnaryOp(op=ast.USub(), operand=ast.Num(n=5))\n```\n\n`InRangeProcessor` shall extract endpoints that are positive or negative numbers.\n\n### Unit Tests\nValid inputs:\n- [[.tst-valid_ints]]: Test that valid integer ranges are extracted.\n- [[.tst-valid_floats]]: Test that valid floating point ranges are extracted.\nInvalid inputs:\n- [[.tst-rejects_inf_nan]]: Test that `NaN` and `inf` are rejected in ranges.\nSemantics:\n- [[.tst-order]]: Test that ranges are rejected when the left literal is greater than the right literal.\n- [[.tst-equal]]: Test that ranges are rejected when the two literals are equal.\n\n## [[.ast2func]]\nThere shall be a method `ast_to_func` that converts an AST into a function. The method shall take the AST and the name of the function as arguments.\n\n### Unit Tests\nValid inputs:\n- [[.tst-func-roundtrip]]: Test that a function converted to an AST and back again still works.\n\n## [[.getter]]:\nThe getter function for the property will have the name `var_getter`, where `var` is the name of the corresponding class variable. The getter shall return the attribute `self._var`. The getter function shall be stored in the `MacroItem` for the corresponding class variable.\n\n## [[.setter]]\nThe setter function for the property will have the name `var_setter`, where `var` is the name of the corresponding class variable. The setter shall only set the value of `self._var` when the provided value is within the range specified in the annotation. The setter function shall be stored in the `MacroItem` for the corresponding class variable.\n\n### Unit Tests\nInvalid inputs:\n- [[.tst-outside_range]]: Test that the setter rejects values not in the specified range.\nValid inputs:\n- [[.tst-in_range]]: Test that the setter accepts values in the specified range.\n\n## [[.property]]\nA property shall be constructed from the getter and setter functions stored in the `MacroItem` instance.\n\n## [[.initast]]: Construct `__init__` AST\nWhen no `__init__` is included with the class definition, the processor shall construct an AST equivalent to\n```\ndef __init__(self):\n    super().__init__()\n```\nThe processor shall have a static method named `InRangeProcessor._make_empty_init_ast()` that produces this AST.\n\n## [[.statements]]: Add initializations to `__init__`\nA statement of the form `self._var = None` shall be appended to the `__init__` AST for each class variable selected for processing. These statements initialize the instance attributes that store the data used by the generated properties.\n\nFor a class definition\n```\nclass MyClass:\n    foo: \"0 < foo < 1\"\n    bar: \"1 < bar < 2\"\n```\nthe following statements should be added to `__init__`:\n```\nself._foo = None\nself._bar = None\n```\n\n### Unit Tests\nBasic function:\n- [[.tst-init_stmts]]: Test that the backing instance variables are created.\n\n## [[.bind]]: Bind `__init__` to class\nTo bind the `__init__` function to the class you execute the following line:\n```python\nsetattr(self.cls, \"__init__\", init_func.__get__(self.cls))\n```\n","impl_":{"type":"Code","value":{"primary":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":20},"secondary":{".ast2func":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":145},".bind":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":300},".collect":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":61},".decorator":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":21},".extract":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":100},".getter":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":157},".initast":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":268},".item":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":44},".parse":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":82},".property":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":309},".setter":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":211},".statements":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py","line":288},".tst-comparison":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":85},".tst-equal":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":173},".tst-init_stmts":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":210},".tst-in_range":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":187},".tst-mixed_strings":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":62},".tst-not_comparison":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":74},".tst-no_annotations":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":41},".tst-no_strings":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":51},".tst-order":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":154},".tst-outside_range":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":198},".tst-rejects_funcs":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":21},".tst-rejects_inf_nan":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":137},".tst-rejects_methods":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":31},".tst-valid_floats":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":117},".tst-valid_ints":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_asts.py","line":97}}}},"subnames":[".ast2func",".bind",".collect",".decorator",".extract",".getter",".initast",".item",".parse",".property",".setter",".statements",".tst-comparison",".tst-equal",".tst-init_stmts",".tst-in_range",".tst-mixed_strings",".tst-not_comparison",".tst-no_annotations",".tst-no_strings",".tst-order",".tst-outside_range",".tst-rejects_funcs",".tst-rejects_inf_nan",".tst-rejects_methods",".tst-valid_floats",".tst-valid_ints"]},"SPC-notify":{"id":"vRp9CnV0oLwnhlAg9cGeiA","name":"SPC-notify","file":"/Users/zmitchell/Projects/annotation-abuse/design/SPC-notify.md","partof":["REQ-notify"],"parts":["SPC-notify-inst","SPC-notify-intercept"],"completed":{"spc":1.0,"tst":1.0},"text":"This project shall implement a decorator, `notify`, that shall only be applied to class definitions. Both class variables ([[SPC-notify.classvars]]) and instance variables ([[SPC-notify-inst]]) shall be searched for the marker annotation. The marked variable will be replaced with a descriptor whose `__set__` method prints a message to the terminal.\n\n## [[.decorator]]\nThe decorator shall only be applied to classes.\n\n## [[.classvars]]: Detect marked class variables\nMarked class variables shall be detected by reading `MyClass.__annotations__` if it exists. This attribute will not exist if there are no annotated class variables).\n\n### Unit Tests\nValid inputs:\n- [[.tst-marked_classvars]]: Test that the names of marked class variables are extracted.\nInvalid inputs:\n- [[.tst-arb_ann]]: Test that arbitrary string annotations are ignored.\n","impl_":{"type":"Code","value":{"primary":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":0},"secondary":{".classvars":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":70},".decorator":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":55},".tst-arb_ann":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":30},".tst-marked_classvars":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":16}}}},"subnames":[".classvars",".decorator",".tst-arb_ann",".tst-marked_classvars"]},"SPC-notify-inst":{"id":"dr61riF9G2QZX5AYFBEdPQ","name":"SPC-notify-inst","file":"/Users/zmitchell/Projects/annotation-abuse/design/SPC-notify.md","partof":["SPC-notify"],"parts":[],"completed":{"spc":1.0,"tst":1.0},"text":"Marked instance variables shall be detected by searching the AST of the class's `__init__` method (if it exists). The marked variables will be detected using the following procedure:\n- Obtain the filename of the module that class resides in.\n- Read the module into a string.\n- Parse the string into an AST.\n- Recursively search the AST until you find the `__init__` method.\n- Recursively search the nodes in the `body` of the `__init__` node, looking for nodes of type `ast.AnnAssign`.\n- Record the attribute name if the attribute is being assigned to is of the form `self.attr`.\n\nSearching for marked instance variables shall be skipped if the class inherits `__init__` from a superclass. Assignments to annotated variables appear in `ast.AnnAssign` nodes. The marked instance variables will appear in `ast.AnnAssign` nodes where the `target` field is of the form `self.var`.\n\n## Unit Tests\nValid inputs:\n- [[.tst-find_ann]]: Test that all marked instance variables are found in a class.\n\n## [[.inherits]]: Determine if `__init__` is inherited\nThe `__qualname__` of `MyClass.__init__` will end with `MyClass.__init__` if it is defined as part of the class.\n\n### Unit Tests\nValid inputs:\n- [[.tst-impl_init]]: Test that a class-defined `__init__` is correctly identified.\n- [[.tst-inherits_init]]: Test that an inherited `__init__` is correctly identified.\n\n## [[.modast]]: Construct an AST for the module\nThe filename of the module can be found in `MyClass.__init__.__code__.co_filename`. The source code should be read into a string and parsed using `ast.parse()`.\n\n## [[.cache]]: Locate all functions/methods in the module\nA cache (dictionary) will be created to hold all of the functions in the module. The dictionary keys will be line numbers, and the values will be the AST nodes of the functions. The line numbers of functions can be obtained from `func.__code__.co_firstlineno`.\n\nThe module should be recursively searched to locate nested functions and class definitions. The search can be carried out by iterating over the nodes in the `body` field of the appropriate AST nodes.\n\n### Unit Tests\nValid inputs:\n- [[.tst-detects_tests]]: Test that the cache locates all of the test functions in `test_notify.py`\n\n## [[.initast]]: Obtain the AST of the `__init__` method\nThe AST will be retrieved from the cache using the line number from `MyClass.__init__.__code__.co_firstlineno`.\n","impl_":{"type":"Code","value":{"primary":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":142},"secondary":{".cache":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":116},".inherits":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":85},".initast":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":131},".modast":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":95},".tst-detects_tests":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":59},".tst-find_ann":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":78},".tst-impl_init":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":40},".tst-inherits_init":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":50}}}},"subnames":[".cache",".inherits",".initast",".modast",".tst-detects_tests",".tst-find_ann",".tst-impl_init",".tst-inherits_init"]},"SPC-notify-intercept":{"id":"3JDzDqpmczVuQM9J3RfbEQ","name":"SPC-notify-intercept","file":"/Users/zmitchell/Projects/annotation-abuse/design/SPC-notify.md","partof":["SPC-notify"],"parts":[],"completed":{"spc":1.0,"tst":1.0},"text":"The decorator shall intercept writes to the marked variables by overriding the class's `__setattr__` method.\n\nThe replacement `__setattr__` should follow this procedure:\n- Detect whether the method is trying to set a marked variable.\n- If not, call the base class's `__setattr__` immediately and return.\n- Generate a message to print to the terminal.\n- Print the message.\n- Collect the user input.\n- Decide whether to set the new value based on user input.\n- Set the new value if necessary.\n\nThe replacement `__setattr__` should be configured as a closure.\n\n### Unit Tests\n- [[.tst-intercepts_inst]]: Test that the new `__setattr__` intercepts writes to marked instance variables.\n- [[.tst-intercepts_class]]: Test that the new `__setattr__` intercepts writes to marked class variables.\n- [[.tst-unmarked_inst]]: Test that writes to unmarked instance variables behave as expected.\n- [[.tst-unmarked_class]]: Test that writes to unmarked class variables behave as expected.\n\n## [[.msg]]\nA message should be shown to the user indicating that a new value is about to be set. The message should fit within a width of 80 characters modulo weird unicode things.\n\n## [[.input]]\nA prompt should be shown to the user saying something along the lines of:\n```\nAccept new value? (Y/n)\n```\nThe prompt shall accept \"Yes\", \"yes\", \"Y\", or \"y\" as affirmative responses, and \"No\", \"no\", \"N\", or \"n\" as negative responses.\n\nWhen a response is given that does not fit the set of allowed answers, a message should be printed indicating that the response was not understood, then the original prompt should be shown again.\n\n### Unit Tests\nValid inputs:\n- [[.tst-prompt_yes]]: Test that an affirmative input produces a \"yes\" response.\n- [[.tst-prompt_no]]: Test that a negative input produces a \"no\" response.\nInvalid inputs:\n- [[.tst-prompt_invalid]]: Test that arbitrary text produces an \"invalid\" response.\n","impl_":{"type":"Code","value":{"primary":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":181},"secondary":{".input":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":260},".msg":{"file":"/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/notify.py","line":209},".tst-intercepts_class":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":113},".tst-intercepts_inst":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":92},".tst-prompt_invalid":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":187},".tst-prompt_no":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":180},".tst-prompt_yes":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":174},".tst-unmarked_class":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":154},".tst-unmarked_inst":{"file":"/Users/zmitchell/Projects/annotation-abuse/tests/test_notify.py","line":133}}}},"subnames":[".input",".msg",".tst-intercepts_class",".tst-intercepts_inst",".tst-prompt_invalid",".tst-prompt_no",".tst-prompt_yes",".tst-unmarked_class",".tst-unmarked_inst"]}}},"web_type":"Static"}